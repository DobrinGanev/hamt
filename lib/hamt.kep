/**
 * @fileOverview Hash Array Mapped Trie.
 * 
 * Code based on: https://github.com/exclipy/pdata
 */
var hamt = {};

var constant := \x -> \ -> x;

/* Configuration
 ******************************************************************************/
var SIZE := 5;

var BUCKET_SIZE := Math.pow(2, SIZE);

var mask := BUCKET_SIZE - 1;

var MAX_INDEX_NODE := BUCKET_SIZE / 2;

var MIN_ARRAY_NODE := BUCKET_SIZE / 4;

/* Nothing
 ******************************************************************************/
var nothing := ({});

var isNothing := function\x -> {
    return x === nothing;
};

var maybe := function\val, def -> {
    return ?isNothing val : def : val;
};

/* Bit Ops
 ******************************************************************************/
/**
 * Hamming weight.
 * 
 * Taken from: http://jsperf.com/hamming-weight
 */
var popcount = function\_x -> {
    var x = _x - ((_x >> 1) & 0x55555555);
    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
    x = (x + (x >> 4)) & 0x0f0f0f0f;
    x = x + (x >> 8);
    x = x + (x >> 16);
    return (x & 0x7f);
};

var hashFragment := function\shift, h  -> {
    return (h >>> shift) & mask;
};

var toBitmap := function\x -> {
    return 1 << x;
};

var fromBitmap := function\bitmap bit -> {
    return popcount(bitmap & (bit - 1));
};

/* Array Ops
 ******************************************************************************/
/**
 * Set a value in an array.
 * 
 * @param at Index to change.
 * @param v New value
 * @param arr Array.
 */
var arrayUpdate := \at v arr -> {
    var len := arr.length;
    var out := new Array(len);
    for (var i = 0; i < len; i = i + 1) 
        out.(i) = arr.(i);
    out.(at) = v;
    return out;
};

/**
 * Remove a value from an array.
 * 
 * @param at Index to remove.
 * @param arr Array.
 */
var arraySpliceOut = \at arr -> {
    var len := arr.length;
    var out := new Array(len - 1);
    var i = 0;
    for (; i < at; i = i + 1)
        out.(i) = arr.(i);
    i = i + 1;
    for (; i < len; i = i + 1)
        out.(i - 1) = arr.(i);
    return out;
};

/**
 * Insert a value into an array.
 * 
 * @param at Index to insert at.
 * @param v Value to insert,
 * @param arr Array.
 */
var arraySpliceIn = \at v arr -> {
    var len := arr.length;
    var out := new Array(len + 1);
    var i = 0;
    for (; i < at; i = i + 1)
        out.(i) = arr.(i);
    out.(i) = v;
    for (; i < len; i = i + 1)
        out.(i + 1) = arr.(i);
    return out;
};

/* 
 ******************************************************************************/
/**
 * Get 32 bit hash of string.
 * 
 * Based on:
 * http://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript-jquery
 */
var hash = \str -> {
    if (typeof str === 'number')
        return str;
    
    var hash = 0;
    for (var i = 0, len = str.length; i < len; i = i + 1) {
        var c = str.charCodeAt(i);
        hash = (((hash << 5) - hash) + c) | 0;
    }
    return hash;
};
hamt.hash = hash;

/* Node Structures
 ******************************************************************************/
/**
 * Empty node.
 */
var empty = ({ __hamt_isEmpty: true });
hamt.empty = empty;

/**
 * Leaf holding a value.
 * 
 * @member hash Hash of key.
 * @member key Key.
 * @member value Value stored.
 */
var Leaf := function \hash key value =self-> {
    self.hash = hash;
    self.key = key;
    self.value = value;
};

/**
 * Leaf holding multiple values with the same hash but different keys.
 * 
 * @member hash Hash of key.
 * @member children Array of collision children node.
 */
var Collision := function \hash children =self-> {
    self.hash = hash;
    self.children = children;
};

/**
 * Internal node with a sparse set of children.
 * 
 * Uses a bitmap and array to pack children.
 * 
 * @member mask Bitmap that encode the positions of children in the array.
 * @member children Array of child nodes.
 */
var IndexedNode := function \mask children =self-> {
    self.mask = mask;
    self.children = children;
};

/**
 * Internal node with many children.
 * 
 * @member count Number of children.
 * @member children Array of child nodes.
 */
var ArrayNode := function \count children =self-> {
    self.count = count;
    self.children = children;
};

/* 
 ******************************************************************************/
var isEmpty = function\x -> {
    return !x || x === empty || (x && x.__hamt_isEmpty);
};

/**
 * Is `node` a leaf node?
 */
var isLeaf = function\node -> {
    return (node === empty
        || node instanceof Leaf
        || node instanceof Collision);
};

/**
 * Expand an indexed node into an array node.
 * 
 * @param frag Index of added child.
 * @param child Added child.
 * @param mask Index node mask before child added.
 * @param subNodes Index node children before child added.
 */
var expand = function\frag, child, bitmap, subNodes -> {
    var bit = bitmap;
    var arr = [];
    var count = 0;
    for (var i = 0; bit; i = i + 1) {
        if (bit & 1) {
            arr.(i) = subNodes.(count);
            count = count + 1;
        }
        bit = bit >>> 1;
    }
    arr.(frag) = child;
    return new ArrayNode(count + 1, arr);
};

/**
 * Collapse an array node into a indexed node.
 */
var pack = function\removed, elements -> {
    var children = [];
    var bitmap = 0;
    
    for (var i = 0, len = elements.length; i < len; i = i + 1) {
        var elem = elements.(i);
        if (i !== removed && !isEmpty(elem)) {
            children.push(elem);
            bitmap = bitmap | (1 << i);
        }
    }
    return new IndexedNode(bitmap, children);
};

/**
 * Merge two leaf nodes.
 * 
 * @param shift Current shift.
 * @param n1 Node.
 * @param n2 Node.
 */
var mergeLeaves = function\shift, h1, n1, h2, n2 -> {
    if (h1 === h2)
        return new Collision(h1, [n2, n1]);
    
    var subH1 = hashFragment(shift, h1);
    var subH2 = hashFragment(shift, h2);
    return new IndexedNode(toBitmap subH1 | toBitmap subH2,
        ?subH1 === subH2
            :[mergeLeaves(shift + SIZE, h1, n1, h2, n2)]
            :?subH1 < subH2 : [n1, n2] : [n2, n1]);
};

/**
 * Update an entry in a collision list.
 * 
 * @param hash Hash of collision.
 * @param list Collision list.
 * @param f Update function.
 * @param k Key to update.
 */
var updateCollisionList = function\h, list, f, k -> {
    var target, i = 0;
    for (var len = list.length; i < len; i = i + 1) {
        var child = list.(i);
        if (child.key === k) {
            target = child;
            break;
        }
    }
    
    var v = ?target : f(target.value) : f();
    return ?isNothing(v)
        :arraySpliceOut(i, list)
        :arrayUpdate(i, new Leaf(h, k, v), list);
};

/* Lookups
 ******************************************************************************/
/**
 * Leaf::get
 */
Leaf.prototype.lookup = function\_, _, k =self-> {
    return ?k === self.key
        :self.value
        :nothing;
};

/**
 * Collision::get
 */
Collision.prototype.lookup = function\_, h, k =self-> {
    if (h === self.hash) {
        var children = self.children;
        for (var i = 0, len = children.length; i < len; i = i + 1) {
            var child = children.(i);
            if (k === child.key)
                return child.value;
        }
    }
    return nothing;
};

/**
 * IndexedNode::get
 */
IndexedNode.prototype.lookup = function\shift, h, k =self-> {
    var frag = hashFragment(shift, h);
    var bit = toBitmap(frag);
    return ?self.mask & bit
        :self.children.(fromBitmap(self.mask, bit)).lookup(shift + SIZE, h, k)
        :nothing;
};

/**
 * ArrayNode::get
 */
ArrayNode.prototype.lookup = function\shift, h, k =self-> {
    var frag = hashFragment(shift, h);
    var child = self.children.(frag);
    return child.lookup(shift + SIZE, h, k);
};

empty.lookup = \ -> nothing;

/* Editing
 ******************************************************************************/
/**
 * Leaf::modify
 */
Leaf.prototype.modify = function\shift, f, h, k =self-> {
   if (k === self.key) {
        var v = f(self.value);
        return ?isNothing v : empty : new Leaf(h, k, v);
    }
    var v = f();
    return ?isNothing v
        :self
        :mergeLeaves(shift, self.hash, self, h, new Leaf(h, k, v));
};

/**
 * Collision::modify
 */
Collision.prototype.modify = function\shift, f, h, k =self-> {
    if (h === self.hash) {
        var list = updateCollisionList(self.hash, self.children, f, k);
        return ?list.length > 1
            :new Collision(self.hash, list)
            :list.(0); // collapse single element collision list
    }
    var v = f();
    return ?isNothing v
        :self
        :mergeLeaves(shift, self.hash, self, h, new Leaf(h, k, v));
};

/**
 * IndexedNode::modify
 */
IndexedNode.prototype.modify = function\shift, f, h, k ={mask children}-> {
    var frag = hashFragment(shift, h);
    var bit = toBitmap(frag);
    var indx = fromBitmap(mask, bit);
    var exists = mask & bit;
    
    var child = (?exists : children.(indx) : empty).modify(shift + SIZE, f, h, k);
    
    var removed = exists && isEmpty(child);
    var added = !exists && !isEmpty(child);
    
    var bitmap = ?removed
        :mask & ~bit
        :?added
            :mask | bit
            :mask;
    
    return ?!bitmap
        :empty
    
    :?removed
        :?children.length <= 2 && isLeaf(children.(indx ^ 1))
            :children.(indx ^ 1) // collapse
            :new IndexedNode(
                bitmap,
                arraySpliceOut(indx, children))
            
    :?added
        :?children.length >= MAX_INDEX_NODE
            :expand(frag, child, mask, children)
            :new IndexedNode(
                bitmap,
                arraySpliceIn(indx, child, children))
    
    // Modify
    :new IndexedNode(
        bitmap,
        arrayUpdate(indx, child, children));
};

/**
 * ArrayNode::modify
 */
ArrayNode.prototype.modify = function\shift f h k =self-> {
    var count = self.count;
    var children = self.children;
    var frag = hashFragment(shift, h);
    var child = children.(frag);
    var newChild = (child || empty).modify(shift + SIZE, f, h, k);
    
    return ?isEmpty(child) && !isEmpty(newChild)
        // add
        :new ArrayNode(
            count + 1,
            arrayUpdate(frag, newChild, children))
    
    :?!isEmpty(child) && isEmpty(newChild)
        // remove
        :?count - 1 <= MIN_ARRAY_NODE
            :pack(frag, children)
            :new ArrayNode(
                count - 1,
                arrayUpdate(frag, empty, children))
    
    // Modify
    :new ArrayNode(
        count,
        arrayUpdate(frag, newChild, children));
};

empty.modify := \_ f h k -> {
    var v = f();
    return ?isNothing(v): empty : new Leaf(h, k, v);
};

/* Queries
 ******************************************************************************/
/**
 * Lookup a value.
 * 
 * Returns the value stored for the given hash and key, or alt if none.
 * 
 * @param alt Fallback value.
 * @param h 32 bit hash.
 * @param k Key.
 * @param m HAMT
 */
var tryGetHash = \alt, h, k, m  ->
    maybe(m.lookup(0, h, k), alt);

hamt.tryGetHash = tryGetHash;

/**
 * Lookup a value using the internal `hash`.
 * 
 * @see getHash
 */
var tryGet = \alt, k, m ->
    tryGetHash(alt, hash k, k, m);

hamt.tryGet = tryGet;

/**
 * Lookup a value.
 * 
 * Returns the value stored for the given hash an key or null if none.
 * 
 * @param h 32 bit hash.
 * @param k Key.
 * @param m HAMT
 */
var getHash = \h, k, m ->
    tryGetHash(null, h, k, m);

hamt.getHash = getHash;

/**
 * Lookup a value using the internal `hash`.
 * 
 * @see getHash
 */
var get = \k, m ->
    tryGet(null, k, m);

hamt.get = get;

/**
 * Does an entry exist?
 * 
 * @param h 32 bit hash.
 * @param k Key.
 * @param m HAMT
 */
var hasHash = \h, k, m ->
    !isNothing(tryGetHash(nothing, h, k, m));

hamt.hasHash = hasHash;

/**
 * Check if a an entry exists using internal `hash`
 * 
 * @see hasHash
 */
var has = \k, m ->
    hasHash(hash(k), k, m);

hamt.has = has;

/* Single Updates
 ******************************************************************************/
/**
 * Modify the value stored for a hash.
 * 
 * Returns the modified data structure. The input `m` is not modified.
 * 
 * @param h 32 bit hash.
 * @param k Key.
 * @param f Function mapping current value to new value.
 * @param m HAMT
 */
var modifyHash = \h, k, f, m ->
    m.modify(0, f, h, k);

hamt.modifyHash = modifyHash;


/**
 * Store a value using the internal `hash` function to calculate the hash from `key`
 * 
 * @see modifyHash
 */
var modify = \k, f, m ->
    modifyHash(hash(k), k, f, m);

hamt.modify = modify;

/**
 * Store a value with an explicit hash.
 * 
 * @param h 32 bit hash.
 * @param k Key.
 * @param v Value to store.
 * @param m HAMT
 */
var setHash = \h, k, v, m ->
    modifyHash(h, k, constant(v), m);

hamt.setHash = setHash;

/**
 * Store a value using the internal `hash` function to calculate the hash from `key`
 * 
 * @see setHash
 */
var set = \k, v, m ->
    setHash(hash(k), k, v, m);

hamt.set = set;

/**
 * Delete a value with an explicit hash.
 * 
 * @param m HAMT
 * @param h 32 bit hash.
 * @param k Key.
 */
var del = constant(nothing);
var removeHash = \h, k, m ->
    modifyHash(h, k, del, m);

hamt.removeHash = removeHash;

/**
 * Delete a value using the internal `hash` function to calculate the hash from `key`
 * 
 * @see removeHash
 */
var remove = \k m ->
    removeHash(hash k, k, m);

hamt.remove = remove;

/* Fold
 ******************************************************************************/
/**
 * Leaf::fold
 */
Leaf.prototype.fold = \f z =self->
    f(z, self);

/**
 * Collision::fold
 */
Collision.prototype.fold = \f z =self->
    self.children.reduce(f, z);

/**
 * IndexedNode::fold
 * 
 * `self.children.reduce(fold@f, z)`
 */
IndexedNode.prototype.fold := \f z =self-> {
    var z1 = z;
    var children = self.children;
    for (var i = 0, len = children.length; i < len; i = i + 1) {
        var c = children.(i);
        z1 = ?c instanceof Leaf
            :f(z1, c)
            :c.fold(f, z1);
    } 
    return z1;
};

/**
 * ArrayNode::fold
 * 
 * `self.children.reduce(fold@f, z)`
 */
ArrayNode.prototype.fold := \f z =self-> {
    var z1 = z;
    var children = self.children;
    for (var i = 0, len = children.length; i < len; i = i + 1) {
        var c = children.(i);
        if (!isEmpty(c))
            z1 = ?c instanceof Leaf
                :f(z1, c)
                :c.fold(f, z1);
    } 
    return z1;
};

/**
 * Visit every entry in the map, aggregating data.
 * 
 * Order of nodes is not guaranteed.
 * 
 * @param f Function mapping previous value and key value object to new value.
 * @param z Starting value.
 * @param m HAMT
 */
var fold = \f, z, m ->
    ?isEmpty m
        :z
        :m.fold(f, z);

hamt.fold = fold;

/* Aggregate
 ******************************************************************************/
/**
 * Get the number of entries.
 * 
 * @param m HAMT.
 */
var inc = \x -> x + 1;
var count = \m ->
    fold(inc, 0, m);

hamt.count = count;

/**
 * Get array of all key value pairs as arrays of [key, value].
 * 
 * Order is not guaranteed.
 *
 * @param m HAMT.
 */
var buildPairs = \p, x -> { p.push(x); return p; };
var pairs = \m ->
    fold(buildPairs, [], m);

hamt.pairs = pairs;


/**
 * Get array of all keys.
 * 
 * Order is not guaranteed.
 * 
 * @param m HAMT.
 */
var buildKeys = \p, {key} -> { p.push(key); return p; };
var keys = \m ->
    fold(buildKeys, [], m);

hamt.keys = keys;


/**
 * Get array of all values.
 * 
 * Order is not guaranteed, duplicates will be preserved.
 * 
 * @param m HAMT.
 */
var buildValues = \p, {value} -> { p.push(value); return p; };
var values = \m ->
    fold(buildValues, [], m);

hamt.values = values;

static module;
static define;
if (typeof module !== 'undefined' && module.exports) {
    module.exports = hamt;
} else if (typeof define == 'function' && define.amd) {
    define('hamt', [], \ -> hamt);
}
